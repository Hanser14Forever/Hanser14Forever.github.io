<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>力扣LeetCode——每日一题 | Gridea</title>
<link rel="shortcut icon" href="https://Hanser14Forever.github.io/favicon.ico?v=1688894196968">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Hanser14Forever.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="力扣LeetCode——每日一题 | Gridea - Atom Feed" href="https://Hanser14Forever.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="👇力扣每天打卡，记录每天学到的东西
👮争取一天不漏，做小孩大人都能看懂的笔记
7.1
1.两数之和
标签：哈希表
思路：创建哈希表，对每个x，先查询表中是否存在target-x，没有则将x插入到哈希表中。
时间复杂度：O(N)
空间复杂..." />
    <meta name="keywords" content="OI,算法" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Hanser14Forever.github.io">
  <img class="avatar" src="https://Hanser14Forever.github.io/images/avatar.png?v=1688894196968" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              力扣LeetCode——每日一题
            </h2>
            <div class="post-info">
              <span>
                2023-07-03
              </span>
              <span>
                17 min read
              </span>
              
                <a href="https://Hanser14Forever.github.io/tag/ffvVIa1cJ/" class="post-tag">
                  # OI
                </a>
              
                <a href="https://Hanser14Forever.github.io/tag/clHG3uc8y/" class="post-tag">
                  # 算法
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>👇力扣每天打卡，记录每天学到的东西<br>
👮争取一天不漏，做小孩大人都能看懂的笔记</p>
<h1 id="71">7.1</h1>
<p><a href="https://leetcode.cn/problems/two-sum/">1.两数之和</a></p>
<p>标签：哈希表</p>
<p>思路：创建哈希表，对每个x，先查询表中是否存在target-x，没有则将x插入到哈希表中。</p>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
<hr>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        ht = dict()
        for i in range(len(nums)):
            if target-nums[i] in ht.keys():
                return [ht[target-nums[i]], i]
            ht[nums[i]] = i
</code></pre>
<ul>
<li>Python中哈希表：用字典<code>dict()</code>实现</li>
</ul>
<hr>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; ht;
        for(int i=0; i&lt;nums.size(); ++i){
            auto it = ht.find(target-nums[i]);
            if(it!=ht.end()){
                return {it-&gt;second, i};
            }
            ht[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>
<ul>
<li>C++中哈希表：用<code>unordered_map&lt;type, type&gt;</code>实现
<ul>
<li><code>ele-&gt;first</code>指代键；<code>ele-&gt;second</code>指代值</li>
</ul>
</li>
<li>C++中在哈希表中寻找元素：
<ul>
<li>先创建一个迭代器：<code>auto it = hashtable.find(ele)</code></li>
<li>表中包含该元素：<code>it!=hashtable.end()</code></li>
</ul>
</li>
<li>C++中返回列表：用<code>{}</code>，与Python区别开</li>
</ul>
<h1 id="72">7.2</h1>
<p><a href="https://leetcode.cn/problems/add-two-numbers/">2.两数相加</a></p>
<p>标签：链表</p>
<p>思路：模拟，设置好进位，考虑好最后一个节点</p>
<p>时间复杂度：O(max(m,n))</p>
<p>空间复杂度：O(1)</p>
<hr>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:
        dummy = ListNode()
        carry, curr = 0, dummy
        while l1 or l2 or carry:
            s = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            carry = s // 10
            s %= 10
            curr.next = ListNode(s)
            curr = curr.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
</code></pre>
<ul>
<li>Python中新建空链表：<code>l = ListNode()</code></li>
<li>Python中新建值为val的链表：<code>l = ListNode(val)</code></li>
<li>Python中，变量当满足条件cond时赋值a，否则赋值b：<code>v = a if cond else b</code></li>
</ul>
<hr>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode();
        int carry = 0;
        ListNode* curr = dummy;
        while(l1 || l2 || carry){
            int s = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + carry;
            carry = s / 10;
            curr-&gt;next = new ListNode(s % 10);
            curr = curr-&gt;next;

            l1 = l1 ? l1-&gt;next : nullptr;
            l2 = l2 ? l2-&gt;next : nullptr;
        } 
        return dummy-&gt;next;
    }
};
</code></pre>
<ul>
<li>C++中新建空链表：<code>ListNode* l = new ListNode()</code></li>
<li>C++中新建值为val的链表：<code>ListNode* l = new ListNode(val)</code></li>
<li>C++中，变量当满足条件cond时赋值a，否则赋值b：<code>v = cond ? a : b</code></li>
</ul>
<h1 id="73">7.3</h1>
<p><a href="https://leetcode.cn/problems/add-two-numbers-ii">445.两数相加II</a></p>
<p>标签：链表，栈</p>
<p>思路：将两链表的值压入栈中，依次取出相加</p>
<p>时间复杂度：O(max(m,n))</p>
<p>空间复杂度：O(m+n)</p>
<hr>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:
        s1, s2 = [], []
        while l1:
            s1.append(l1.val)
            l1 = l1.next
        while l2:
            s2.append(l2.val)
            l2 = l2.next
        
        head, carry = None, 0
        while s1 or s2 or carry:
            s = (s1.pop() if s1 else 0) + (s2.pop() if s2 else 0) + carry
            carry = s // 10
            curnode = ListNode(s%10)
            curnode.next = head
            head = curnode
        
        return head
</code></pre>
<ul>
<li>
<p>Python中栈：由列表<code>list()</code>实现</p>
<ul>
<li>
<p>栈的push：<code>l.append(ele)</code></p>
</li>
<li>
<p>栈的pop：<code>l.pop()</code></p>
</li>
<li>
<p>栈顶元素：<code>l[-1]</code></p>
</li>
</ul>
</li>
<li>
<p><strong>板子</strong>：Python链表中，每次新加节点到表头，实现方法：</p>
<pre><code class="language-python">head = None
while cond:
    curnode = ListNode(val)
    curnode.next = head
    head = curnode
</code></pre>
</li>
</ul>
<hr>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack&lt;int&gt; s1, s2;
        while (l1) {
            s1.push(l1-&gt;val);
            l1 = l1-&gt;next;
        }
        while (l2) {
            s2.push(l2-&gt;val);
            l2 = l2-&gt;next;
        }

        int carry = 0;
        ListNode* head = nullptr;
        while (!s1.empty() || !s2.empty() || carry) {
            int s = (!s1.empty() ? s1.top() : 0) + (!s2.empty() ? s2.top() : 0) + carry;
            if (!s1.empty()) s1.pop();
            if (!s2.empty()) s2.pop();
            carry = s / 10;
            ListNode* curnode = new ListNode(s%10);
            curnode-&gt;next = head;
            head = curnode;
        }
        return head;
    }
};

</code></pre>
<ul>
<li>
<p>C++中栈的实现：<code>stack&lt;int&gt; s</code></p>
<ul>
<li>
<p>栈的push：<code>s.push(ele)</code></p>
</li>
<li>
<p>栈的pop：<code>s.pop()</code></p>
</li>
<li>
<p>栈顶元素：<code>s.top()</code></p>
</li>
</ul>
</li>
<li>
<p><strong>板子</strong>：C++链表中，每次新加节点到表头，实现方法：</p>
<pre><code class="language-C++">ListNode* head = nullptr;
while (cond) {
	ListNode* curnode = new ListNode(val);
    curnode-&gt;next = head;
    head = curnode;
}
</code></pre>
</li>
</ul>
<h1 id="74">7.4</h1>
<p><a href="https://leetcode.cn/problems/sum-in-a-matrix/">2679.矩阵中的和</a></p>
<p>标签：矩阵，堆，优先队列</p>
<p>思路：直接每行排序，每列取最大即可；下面用到利用最大堆的方法，对每行建立一个最大堆，每次pop出每行的最大元素，求最大值相加即可</p>
<p>时间复杂度：O(mnlogn)（优先队列中每次压入或者弹出元素需要的时间复杂度为O(logn)）</p>
<p>空间复杂度：O(mn)</p>
<hr>
<p><strong>知识</strong>：堆，即优先队列，满足以下性质：</p>
<ul>
<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（<strong>堆序性</strong>）。</li>
<li>堆总是一棵<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全树</a>。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>
</ul>
<img src="C:\Users\asus\Documents\Gridea\post-images\17856624-11acd3cf5c6f6e1b.webp" style="zoom: 33%;" />
<hr>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def matrixSum(self, nums: List[List[int]]) -&gt; int:
        res = 0
        m, n = len(nums), len(nums[0])
        pq = []
        for i in range(m):
            pq.append([])
            for j in range(n):
                heapq.heappush(pq[i], -nums[i][j])
        for j in range(n):
            maxVal = 0
            for i in range(m):
                maxVal = max(maxVal, -heapq.heappop(pq[i]))
            res += maxVal
        return res
</code></pre>
<ul>
<li>Python中新建堆（默认最小堆，最大堆将元素取负）：<code>heap = heapq.heapify(list)</code></li>
<li>Python中堆的push：<code>heapq.heappush(heap, ele)</code></li>
<li>Python中堆的pop：<code>heapq.heappop(heap)</code></li>
</ul>
<hr>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int matrixSum(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        int res = 0;
        int m = nums.size();
        int n = nums[0].size();
        vector&lt;priority_queue&lt;int&gt;&gt; pq(m);
        for(int i = 0; i &lt; m; ++i){
            for(int j = 0; j &lt; n; ++j){
                pq[i].emplace(nums[i][j]);
            }
        }
        for(int j = 0; j &lt; n; ++j){
            int maxVal = 0;
            for(int i = 0; i &lt; m; ++i){
                maxVal = max(maxVal, pq[i].top());
                pq[i].pop();
            }
            res += maxVal;
        }
        return res;
    }
};
</code></pre>
<ul>
<li>C++中新建堆（默认最大堆）：<code>priority_queue&lt;int&gt; q</code></li>
<li>C++中新建最小堆：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q</code></li>
<li>C++中堆的push：<code>q.emplace(ele)</code></li>
<li>C++中堆的pop：<code>q.pop()</code></li>
<li>C++中堆顶元素：<code>q.top()</code></li>
</ul>
<h1 id="75">7.5</h1>
<p><a href="https://leetcode.cn/problems/k-items-with-the-maximum-sum/">2600.K件物品的最大值</a>（简单）</p>
<p>标签：贪心</p>
<p>思路：最简单的贪心，保证前k个均为最大即可</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<hr>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -&gt; int:
        if k &gt; numOnes + numZeros:
            return numOnes - (k - numOnes - numZeros)
        else:
            return min(numOnes, k)
</code></pre>
<hr>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        if(k &gt; numOnes + numZeros){
            return numOnes - (k - numOnes - numZeros);
        }else{
            return min(numOnes, k);
        }
    }
};
</code></pre>
<h1 id="76">7.6</h1>
<p><a href="https://leetcode.cn/problems/maximum-split-of-positive-even-integers/">2178.拆分成最多数目的正偶数之和</a></p>
<p>标签：贪心，数学</p>
<p>思路：贪心从最小的偶数开始枚举，若该偶数不超过当前目标所剩值的一半，则加入当前列表</p>
<p>时间复杂度：O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>)</p>
<p>空间复杂度：O(n)</p>
<hr>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def maximumEvenSplit(self, finalSum: int) -&gt; List[int]:
        if finalSum % 2:
            return []

        ans = []
        for i in range(2,finalSum+1,2):
            if 2*i &gt;= finalSum:
                break
            ans.append(i)
            finalSum-=i
        ans.append(finalSum)
        return ans
</code></pre>
<hr>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;long long&gt; maximumEvenSplit(long long finalSum) {
        if(finalSum % 2){
            return {};
        }

        vector&lt;long long&gt; ans;
        for(int i = 2; i&lt;=finalSum; i = i + 2){
            if(2*i &gt;= finalSum) break;
            ans.push_back(i);
            finalSum-=i;
        }
        ans.push_back(finalSum);
        return ans;
    }
};
</code></pre>
<h1 id="77">7.7</h1>
<p><a href="https://leetcode.cn/problems/time-to-cross-a-bridge/">2532.过桥的时间</a>（困难）</p>
<p>标签：模拟，堆（优先队列）</p>
<p>思路：</p>
<p>​	用四个优先队列模拟工人的状态：</p>
<ul>
<li>
<p><code>wait_in_left</code>：大根堆，存储当前在左岸等待的工人的下标</p>
</li>
<li>
<p><code>wait_in_right</code>：大根堆，存储当前在右岸等待的工人的下标</p>
</li>
<li>
<p><code>work_in_left</code>：小根堆，存储当前在左岸工作的工人放好箱子的时间以及工人的下标</p>
</li>
<li>
<p><code>work_in_right</code>：小根堆，存储当前在右岸工作的工人放好箱子的时间以及工人的下标</p>
<p>先把工人按效率从高到低排序，之后模拟过程：</p>
</li>
<li>
<p>初始时，所有工人在左岸，<code>wait_in_left</code>存储所有工人下标，记录当前时间</p>
</li>
<li>
<p>先判断<code>work_in_left</code>和<code>work_in_right</code>中是否有工人已经放好箱子，如果有，放入wait堆中，并从work堆中移除</p>
</li>
<li>
<p>再判断当前是否有工人在左、右岸等待，分别用<code>left_to_go</code>和<code>right_to_go</code>记录。</p>
<ul>
<li>如果均为<code>False</code>，即没有等待的工人，直接将时间更新为下一个工人放好箱子的时间</li>
<li>如果<code>right_to_go</code>为<code>True</code>，则从<code>wait_in_right</code>中取出工人，更新时间为加上该工人过岸的时间。再判断：如果所有工人都不在右岸，则直接返回当前时间；否则，将当前工人加入到<code>work_in_left</code>中</li>
<li>如果<code>left_to_go</code>为True，则从<code>wait_in_left</code>中取出工人，更新时间为加上该工人过岸的时间。将箱子数量减一，将当前工人加入到<code>work_in_right</code>中</li>
</ul>
</li>
</ul>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p>
<hr>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -&gt; int:
        time.sort(key = lambda x: x[0] + x[2])

        cur = 0
        wait_in_left, wait_in_right = [], []
        work_in_left, work_in_right = [], []
        for i in range(k):
            heappush(wait_in_left, -i)

        while 1:
            while work_in_left:
                t, i = work_in_left[0]
                if t &gt; cur:
                    break
                heappop(work_in_left)
                heappush(wait_in_left, -i)
            while work_in_right:
                t, i = work_in_right[0]
                if t &gt; cur:
                    break
                heappop(work_in_right)
                heappush(wait_in_right, -i) 
            left_to_go = n &gt; 0 and wait_in_left
            right_to_go = bool(wait_in_right)
            if not left_to_go and not right_to_go:
                nxt = inf
                if work_in_left:
                    nxt = min(nxt, work_in_left[0][0])
                if work_in_right:
                    nxt = min(nxt, work_in_right[0][0])
                cur = nxt
            elif right_to_go:
                i = -heappop(wait_in_right)
                cur += time[i][2]
                if n == 0 and not wait_in_right and not work_in_right:
                    return cur
                heappush(work_in_left, (cur + time[i][3], i))
            elif left_to_go:
                i = -heappop(wait_in_left)
                cur += time[i][0]
                n -= 1
                heappush(work_in_right, (cur + time[i][1], i))
</code></pre>
<ul>
<li>
<p><code>heappush</code>等函数前的<code>heapq</code>可省略</p>
</li>
<li>
<p>Python中按键排序数组：<code>list.sort(key = lambda x: x[0])</code></p>
</li>
</ul>
<hr>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int findCrossingTime(int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; time) {
        using pii = pair&lt;int, int&gt;;
        for(int i = 0; i &lt; k; ++i){
            time[i].push_back(i);
        }
        sort(time.begin(), time.end(),  [](auto&amp; a, auto&amp; b){
            int x = a[0] + a[2];
            int y = b[0] + b[2];
            return x == y ? a[4] &lt; b[4] : x &lt; y;
        });
        int cur = 0;
        priority_queue&lt;int&gt; wait_in_left, wait_in_right;
        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; work_in_left, work_in_right;
        for(int i = 0; i &lt; k; ++i){
            wait_in_left.push(i);
        }
        while(true){
            while(!work_in_left.empty()){
                auto [t, i] = work_in_left.top();
                if(t &gt; cur){
                    break;
                }
                work_in_left.pop();
                wait_in_left.push(i);
            }
            while(!work_in_right.empty()){
                auto [t, i] = work_in_right.top();
                if(t &gt; cur){
                    break;
                }
                work_in_right.pop();
                wait_in_right.push(i);
            }
            bool left_to_go = n &gt; 0 &amp;&amp; !wait_in_left.empty();
            bool right_to_go = !wait_in_right.empty();
            if(!left_to_go &amp;&amp; !right_to_go){
                int nxt = 1 &lt;&lt; 30;
                if(!work_in_left.empty()){
                    nxt = min(nxt, work_in_left.top().first);
                }
                if(!work_in_right.empty()){
                    nxt = min(nxt, work_in_right.top().first);
                }
                cur = nxt;
            }else if(right_to_go){
                int i = wait_in_right.top();
                wait_in_right.pop();
                cur += time[i][2];
                if(n == 0 &amp;&amp; wait_in_right.empty() &amp;&amp; work_in_right.empty()){
                    return cur;
                }
                work_in_left.push({cur + time[i][3], i});
            }else if(left_to_go){
                int i = wait_in_left.top();
                wait_in_left.pop();
                cur += time[i][0];
                --n;
                work_in_right.push({cur + time[i][1], i});
            }
        }
    }
};
</code></pre>
<ul>
<li>
<p>C++中排序+lambda匿名表达式：</p>
<pre><code class="language-c++">sort(list.begin(), list.end(), [](auto&amp; a, auto&amp; b){
	return a[0] &lt; b[0]
});
</code></pre>
<p>这里<code>auto&amp;</code>带引用表示数组</p>
</li>
<li>
<p>C++中对元组（pair）构建优先队列：</p>
<pre><code class="language-c++">using pii = pair&lt;int, int&gt;;
priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; work_in_left, work_in_right;
</code></pre>
</li>
</ul>
<h1 id="78">7.8</h1>
<p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167.两数之和 II - 输入有序数组</a></p>
<p>标签：数组，双指针，二分查找</p>
<p>思路：可以用哈希做，但忽略了数组有序性质。若利用有序性质，有二分查找和双指针两种方法</p>
<p>时间复杂度：</p>
<ul>
<li>二分查找：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li>双指针：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>二分查找：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li>双指针：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<hr>
<p>二分查找：</p>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        n = len(numbers)

        for i in range(n):
            low, high = i+1, n-1
            while low &lt;= high:
                mid = low + (high - low) // 2
                if numbers[mid] + numbers[i] == target:
                    return [i+1, mid+1]
                elif numbers[mid] + numbers[i] &lt; target:
                    low = mid + 1
                else:
                    high = mid - 1
</code></pre>
<ul>
<li>
<p><strong>板子</strong>：Python中二分查找：</p>
<pre><code class="language-python">while low &lt;= high:
    mid = low + (high - low) // 2
  if list[mid] == target:
        return mid
    elif list[mid] &lt; target:
        low = mid + 1
    else:
    	high = mid - 1
</code></pre>
</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int n = numbers.size();

        for(int i = 0; i &lt; n; ++i){
            int low = i + 1;
            int high =  n - 1;
            while(low &lt;= high){
                int mid = low + (high - low) / 2;
                if(numbers[mid] + numbers[i] == target) return {i + 1, mid + 1};
                else if(numbers[mid] + numbers[i] &lt; target) low = mid + 1;
                else high = mid - 1;
            }
        }
        return {};
    }
};
</code></pre>
<ul>
<li>
<p><strong>板子</strong>：C++中二分查找：</p>
<pre><code class="language-c++">while(low &lt;= high){
    int mid = low + (high - low) / 2;
    if(list[mid] == target) return mid;
	else if(list[mid] &lt; target) low = mid + 1;
    else high = mid - 1
}
</code></pre>
</li>
</ul>
<hr>
<p>双指针：<strong>有序数组双指针缩小范围，必能找到目标</strong></p>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        low, high = 0, len(numbers) - 1
        while low &lt; high:
            total = numbers[low] + numbers[high]
            if total == target:
                return [low + 1, high + 1]
            elif total &lt; target:
                low += 1
            else:
                high -= 1
        return [-1, -1]
</code></pre>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int low = 0, high = numbers.size() - 1;
        while (low &lt; high) {
            int sum = numbers[low] + numbers[high];
            if (sum == target) {
                return {low + 1, high + 1};
            } else if (sum &lt; target) {
                ++low;
            } else {
                --high;
            }
        }
        return {-1, -1};
    }
};
</code></pre>
<h1 id="79">7.9</h1>
<p><a href="https://leetcode.cn/problems/3sum/">15.三数之和</a></p>
<p>标签：数组，双指针</p>
<p>思路：固定第一个数，双指针寻找后两个数。重点在于跳过重复解</p>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<hr>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:
        ans = []
        nums.sort()
        for i in range(len(nums)-2):
            left, right = i+1, len(nums)-1
            while left &lt; right:
                if nums[left] + nums[right] + nums[i] &lt; 0:
                    left += 1
                elif nums[left] + nums[right] + nums[i] &gt; 0:
                    right -= 1
                else:
                    res = [nums[i], nums[left], nums[right]]
                    if res not in ans:
                        ans.append(res)
                        
                    break
        return ans
</code></pre>
<hr>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; ans;
        sort(nums.begin(), nums.end());
        for(int i = 0; i &lt; nums.size(); ++i){
            if(nums[i]&gt;0) return ans;
            if(i &gt; 0 and nums[i] == nums[i-1]) continue;
            int left = i+1;
            int right = nums.size()-1;
            while(left &lt; right){
                if(nums[i] + nums[left] + nums[right] &gt; 0) right--;
                else if(nums[i] + nums[left] + nums[right] &lt; 0) left++;
                else{
                    vector&lt;int&gt; res = {nums[i], nums[left], nums[right]};
                    ans.push_back(res);
                    while(left &lt; right and nums[left] == nums[left+1]) left++;
                    while(left &lt; right and nums[right] == nums[right-1]) right--;
                    left++;
                    right--;
                }
            }
        }
        return ans;
    }
};
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#71">7.1</a></li>
<li><a href="#72">7.2</a></li>
<li><a href="#73">7.3</a></li>
<li><a href="#74">7.4</a></li>
<li><a href="#75">7.5</a></li>
<li><a href="#76">7.6</a></li>
<li><a href="#77">7.7</a></li>
<li><a href="#78">7.8</a></li>
<li><a href="#79">7.9</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Hanser14Forever.github.io/post/Pycharm-ri-ji-git-push-shi-chu-xian-Failed-to-connect-to-github-com-port-443-Timed-out/">
              <h3 class="post-title">
                Pycharm日记——git push时出现Failed to connect to github.com port 443: Timed out
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://Hanser14Forever.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
